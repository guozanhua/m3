package native

import (
	"testing"
	"time"

	"code.uber.internal/infra/statsdex/context"
	"code.uber.internal/infra/statsdex/index"
	"code.uber.internal/infra/statsdex/policy/resolver"
	"code.uber.internal/infra/statsdex/storage/local"
	"code.uber.internal/infra/statsdex/storage/partitioning"
	"github.com/m3db/m3/src/query/graphite/common"
	"github.com/m3db/m3/src/query/graphite/errors"
	"github.com/m3db/m3/src/query/graphite/tsdb"
	"github.com/m3db/m3/src/query/graphite/tsdb/mocktsdb"

	"code.uber.internal/go-common.git/x/metrics"
	"code.uber.internal/go-common.git/x/metrics/metricstest"
	"code.uber.internal/go-common.git/x/sync/instrumented"

	"github.com/m3db/m3/src/metrics/policy"
	xtime "github.com/m3db/m3x/time"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type queryTestResult struct {
	name string
	max  float64
}

type queryTest struct {
	query   string
	ordered bool
	results []queryTestResult
}

type fakeIndex struct {
	//paths   map[string][]string
	queries map[string][]index.MetricMetadata
}

func (idx *fakeIndex) QueryMetadata(
	_ context.Context, query string, _ index.Enforcer, _ index.QueryOptions,
) ([]index.MetricMetadata, error) {
	return idx.queries[query], nil
}

func (idx *fakeIndex) FindMetrics(
	ctx context.Context, path string, enforcer index.Enforcer, _ index.QueryOptions,
) ([]index.PathInfo, error) {
	return nil, errors.NewInvalidParamsError(errors.New("unexpected use")) // unused here
}

func (idx *fakeIndex) NewPartitionIter(ctx context.Context, partitionID uint32) (partitioning.PartitionIter, error) {
	return nil, errors.NewInvalidParamsError(errors.New("unexpected use")) // unused here
}

var (
	testValues = map[string]float64{
		"foo.bar.q.zed":       0,
		"foo.bar.g.zed":       1,
		"foo.bar.x.zed":       2,
		"san_francisco.uberx": 3,
		"new_york_city.uberx": 4,
		"chicago.uberx":       5,
		"los_angeles.uberx":   6,
	}

	testPolicy          = policy.NewStoragePolicy(10*time.Second, xtime.Second, 48*time.Hour)
	testIndex, testTSDB = makeIndexAndTSDB(testPolicy)
	workers             = instrumented.NewInstrumentedWorkerPool(5, metricstest.NewTestScope())
	testStorage         = local.NewLocalStorage(local.Options{
		Database:       testTSDB,
		Index:          testIndex,
		Workers:        workers,
		Scope:          metrics.None,
		PolicyResolver: resolver.NewStaticResolver(testIndex, testPolicy),
	})
)

func TestExecute(t *testing.T) {
	engine := NewEngine(
		testStorage,
		metrics.None,
		common.NewMockCostAccounting(nil),
	)
	tests := []queryTest{
		{"foo.bar.q.zed", true, []queryTestResult{{"foo.bar.q.zed", 0}}},
		{"foo.bar.*.zed", false, []queryTestResult{
			{"foo.bar.q.zed", 0},
			{"foo.bar.g.zed", 1},
			{"foo.bar.x.zed", 2}},
		},
		{"sortByName(aliasByNode(foo.bar.*.zed, 0, 2))", true, []queryTestResult{
			{"foo.g", 1},
			{"foo.q", 0},
			{"foo.x", 2},
		}},
	}

	ctx := common.NewContext(common.ContextOptions{Start: time.Now().Add(-1 * time.Hour), End: time.Now(), Engine: engine})
	for _, test := range tests {
		expr, err := engine.Compile(test.query)
		require.Nil(t, err)

		results, err := expr.Execute(ctx)
		require.Nil(t, err, "failed to execute %s", test.query)
		require.Equal(t, len(test.results), len(results.Values), "invalid results for %s", test.query)

		for i := range test.results {
			if test.ordered {
				assert.Equal(t, test.results[i].name, results.Values[i].Name(),
					"invalid result %d for %s", i, test.query)
				assert.Equal(t, test.results[i].max, results.Values[i].CalcStatistics().Max,
					"invalid result %d for %s", i, test.query)
			}
		}
	}
}

func TestTracing(t *testing.T) {
	engine := NewEngine(
		testStorage,
		metrics.None,
		common.NewMockCostAccounting(nil),
	)
	var traces []common.Trace

	ctx := common.NewContext(common.ContextOptions{Start: time.Now().Add(-1 * time.Hour), End: time.Now(), Engine: engine})
	ctx.Trace = func(t common.Trace) {
		traces = append(traces, t)
	}

	expr, err := engine.Compile("groupByNode(sortByName(aliasByNode(foo.bar.*.zed, 0, 2)), 0, 'sumSeries')")
	require.NoError(t, err)

	_, err = expr.Execute(ctx)
	require.NoError(t, err)

	expectedTraces := []common.Trace{
		common.Trace{
			ActivityName: "fetch foo.bar.*.zed",
			Outputs:      common.TraceStats{NumSeries: 3}},
		common.Trace{
			ActivityName: "aliasByNode",
			Inputs:       []common.TraceStats{common.TraceStats{NumSeries: 3}},
			Outputs:      common.TraceStats{NumSeries: 3}},
		common.Trace{
			ActivityName: "sortByName",
			Inputs:       []common.TraceStats{common.TraceStats{NumSeries: 3}},
			Outputs:      common.TraceStats{NumSeries: 3}},
		common.Trace{
			ActivityName: "groupByNode",
			Inputs:       []common.TraceStats{common.TraceStats{NumSeries: 3}},
			Outputs:      common.TraceStats{NumSeries: 1}},
	}
	require.Equal(t, len(expectedTraces), len(traces))
	for i, expected := range expectedTraces {
		trace := traces[i]
		assert.Equal(t, expected.ActivityName, trace.ActivityName, "incorrect name for trace %d", i)
		assert.Equal(t, expected.Inputs, trace.Inputs, "incorrect inputs for trace %d", i)
		assert.Equal(t, expected.Outputs, trace.Outputs, "incorrect outputs for trace %d", i)
	}
}

func makeIndexAndTSDB(policy policy.StoragePolicy) (index.ReadableIndex, tsdb.Database) {
	testIndex := &fakeIndex{
		queries: map[string][]index.MetricMetadata{
			"foo.bar.*.zed": []index.MetricMetadata{
				index.MetricMetadata{
					ID: "foo.bar.q.zed",
				},
				index.MetricMetadata{
					ID: "foo.bar.g.zed",
				},
				index.MetricMetadata{
					ID: "foo.bar.x.zed",
				},
			},
			"foo.bar.q.zed": []index.MetricMetadata{
				index.MetricMetadata{
					ID: "foo.bar.q.zed",
				},
			},
			"*<vehicle:uberx>": []index.MetricMetadata{
				index.MetricMetadata{
					ID:   "san_francisco.uberx",
					Tags: map[string]string{"vehicle": "uberx", "name": "san_francisco.uberx"},
				},
				index.MetricMetadata{
					ID:   "new_york_city.uberx",
					Tags: map[string]string{"vehicle": "uberx", "name": "new_york_city.uberx"},
				},
				index.MetricMetadata{
					ID:   "chicago.uberx",
					Tags: map[string]string{"vehicle": "uberx", "name": "chicago.uberx"},
				},
				index.MetricMetadata{
					ID:   "los_angeles.uberx",
					Tags: map[string]string{"vehicle": "uberx", "name": "los_angeles.uberx"},
				},
			},
		},
	}

	var (
		now      = time.Now().Truncate(time.Second * 10)
		testTSDB = mocktsdb.New()
		ctx      = context.New()
	)

	defer ctx.Close()

	for name, val := range testValues {
		for t := now.Add(-time.Hour * 2); t.Before(now.Add(time.Hour)); t = t.Add(time.Second * 10) {
			testTSDB.WriteRaw(ctx, name, t, val, policy)
		}
	}

	return testIndex, testTSDB
}
