package common

import (
	"fmt"
	"net/http"
	"sync"

	"code.uber.internal/infra/statsdex/context"
	qgraphite "code.uber.internal/infra/statsdex/services/query/graphite"
	"code.uber.internal/infra/statsdex/x/m3db/log"

	"code.uber.internal/go-common.git/x/log"

	"github.com/m3db/m3/src/cluster/kv"
	"github.com/m3db/m3/src/cluster/kv/util"
	xlog "github.com/m3db/m3x/log"
)

// BlacklistType defines the type of query server to run.
type BlacklistType string

// supported blacklist types
const (
	QuerySourceBlacklist     BlacklistType = "query.source.blacklist"
	QuerySourceSlowBlacklist BlacklistType = "query.source.slowblacklist"
	QueryTimeWhitelistType   BlacklistType = "query.time.whitelist"
)

const (
	keyFmt           = "%s.%s"
	userType         = "user"
	dashboardType    = "dashboard"
	sourceType       = "source"
	chargebackIDType = "chargebackid"
)

// QueryBlacklists are all the blacklists for different types of query sources
type QueryBlacklists struct {
	ChargebackBlacklist *QueryBlacklist
	UserBlacklist       *QueryBlacklist
	DashboardBlacklist  *QueryBlacklist
	SourceBlacklist     *QueryBlacklist
}

// NewQueryBlacklists creates a new QueryBlacklists
func NewQueryBlacklists() *QueryBlacklists {
	return &QueryBlacklists{
		ChargebackBlacklist: NewQueryBlacklist(),
		UserBlacklist:       NewQueryBlacklist(),
		DashboardBlacklist:  NewQueryBlacklist(),
		SourceBlacklist:     NewQueryBlacklist(),
	}
}

// IsBlacklisted returns true if any of the sources of the query are blacklisted
func (q *QueryBlacklists) IsBlacklisted(owner *context.OwnerInfo) bool {
	return q.ChargebackBlacklist.IsBlacklisted(owner.ChargebackID) ||
		q.UserBlacklist.IsBlacklisted(owner.User) ||
		q.DashboardBlacklist.IsBlacklisted(owner.Dashboard) ||
		q.SourceBlacklist.IsBlacklisted(owner.Source)
}

// UpdateBlacklistsKV updates blacklists with value on kv store
func UpdateBlacklistsKV(store kv.Store, blacklistType BlacklistType, queryBlacklists *QueryBlacklists) error {
	if err := updateBlacklistKV(
		store,
		kvKey(blacklistType, userType),
		queryBlacklists.UserBlacklist,
	); err != nil {
		return err
	}

	if err := updateBlacklistKV(
		store,
		kvKey(blacklistType, dashboardType),
		queryBlacklists.DashboardBlacklist,
	); err != nil {
		return err
	}

	if err := updateBlacklistKV(
		store,
		kvKey(blacklistType, sourceType),
		queryBlacklists.SourceBlacklist,
	); err != nil {
		return err
	}

	if err := updateBlacklistKV(
		store,
		kvKey(blacklistType, chargebackIDType),
		queryBlacklists.ChargebackBlacklist,
	); err != nil {
		return err
	}

	return nil
}

func kvKey(blacklistType BlacklistType, subType string) string {
	return fmt.Sprintf(keyFmt, blacklistType, subType)
}

// QueryBlacklist is a blacklist for a particular type of query source
type QueryBlacklist struct {
	sync.RWMutex
	blacklist map[string]struct{}
}

// NewQueryBlacklist creates a new QueryBlacklist
func NewQueryBlacklist() *QueryBlacklist {
	return &QueryBlacklist{
		blacklist: map[string]struct{}{},
	}
}

// Len returns the length of the blacklist
func (q *QueryBlacklist) Len() int {
	q.RLock()
	length := len(q.blacklist)
	q.RUnlock()
	return length
}

// IsBlacklisted returns true if the source of the query is blacklisted
func (q *QueryBlacklist) IsBlacklisted(key string) bool {
	q.RLock()
	if _, ok := q.blacklist[key]; ok {
		q.RUnlock()
		return true
	}

	q.RUnlock()
	return false
}

// Clear clears the blacklist items
func (q *QueryBlacklist) Clear() {
	q.Lock()
	q.blacklist = map[string]struct{}{}
	q.Unlock()
}

// AddItem adds an item to the blacklist
func (q *QueryBlacklist) AddItem(key string) {
	q.Lock()
	q.blacklist[key] = struct{}{}
	q.Unlock()
}

func updateBlacklistKV(store kv.Store, key string, queryBlacklist *QueryBlacklist) error {
	w, err := store.Watch(key)
	if err != nil {
		return err
	}

	go func() {
		var (
			logger = xm3dblog.DefaultLogger()
			opts   = util.NewOptions().SetLogger(logger)
		)

		for {
			select {
			case <-w.C():
				newItems, err := util.StringArrayFromValue(w.Get(), key, nil, opts)
				if err != nil {
					logger.WithFields(
						xlog.NewField("key", key),
						xlog.NewErrField(err),
					).Error("encountered error converting kv update to string array")
					continue
				}
				updateItems(queryBlacklist, newItems)
			}
		}
	}()

	return nil
}

func updateItems(list *QueryBlacklist, newItems []string) {
	list.Clear()
	for _, item := range newItems {
		list.AddItem(item)
	}
}

// TimeBlacklist represents a query blacklist based on query time
type TimeBlacklist struct {
	longerThanHrs float64
	sync.RWMutex
}

// IsBlacklisted returns true is the query is blacklisted due to it's time range
func (t *TimeBlacklist) IsBlacklisted(r *http.Request) bool {
	blockedHrs := t.BlockTimeHrs()

	if blockedHrs == 0 {
		// Disabled
		return false
	}

	params, err := qgraphite.ParseRenderRequest(r)
	if err != nil {
		log.Warnf("Error in parsing incoming render request for times: %v", err)
		return false
	}

	dur := params.Until.Sub(params.From)
	return dur.Hours() > blockedHrs
}

// BlockTimeHrs returns the amount of hours that querys are blocked above
func (t *TimeBlacklist) BlockTimeHrs() float64 {
	t.RLock()
	blockedHrs := t.longerThanHrs
	t.RUnlock()

	return blockedHrs
}

// UpdateTimeBlacklistKV updates a TimeBlacklist with value on m3kv
func UpdateTimeBlacklistKV(store kv.Store, key string, timeBlacklist *TimeBlacklist) {
	watchOpts := util.NewOptions().SetLogger(xm3dblog.DefaultLogger())
	util.WatchAndUpdateFloat64(
		store, key, &timeBlacklist.longerThanHrs, &timeBlacklist.RWMutex, 0, watchOpts,
	)
}
